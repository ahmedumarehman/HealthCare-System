{"ast":null,"code":"// Known suspicious/hacked wallet addresses (in a real app, this would be fetched from a security API)\nconst SUSPICIOUS_ADDRESSES = ['0x1234567890abcdef1234567890abcdef12345678',\n// Example fake address\n'0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n// Example malicious address\n'0x0000000000000000000000000000000000000000',\n// Null address\n'0xffffffffffffffffffffffffffffffffffffffff' // Max address (suspicious)\n// Add more known suspicious addresses here\n];\n\n// Common patterns for suspicious addresses\nconst SUSPICIOUS_PATTERNS = [/^0x0+$/,\n// All zeros\n/^0xf+$/i,\n// All Fs\n/^0x(dead|beef|cafe|babe|face)/i,\n// Common test/fake patterns\n/^0x1234567890abcdef/i // Sequential pattern\n];\nexport class ClipboardMonitoringService {\n  constructor() {\n    this.isMonitoring = false;\n    this.lastClipboardContent = '';\n    this.alertSound = null;\n    this.onSuspiciousAddressCallback = void 0;\n    this.pasteHandler = null;\n    this.copyHandler = null;\n    this.cutHandler = null;\n    this.focusHandler = null;\n    this.manualCheckInterval = null;\n    this.permissionDeniedNotified = false;\n    // Declare missing properties\n    this.handleClipboardEvent = void 0;\n    this.onFocus = void 0;\n    this.requestClipboardPermission = void 0;\n    this.intervalId = null;\n    // Create alert sound\n    this.alertSound = new Audio();\n    // Replace the long base64 string with a shorter valid one for demonstration purposes\n    this.alertSound.src = 'data:audio/wav;base64,UklGRh4AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';\n\n    // Implement missing methods\n    this.handleClipboardEvent = e => {\n      console.log('Clipboard event detected:', e.type);\n    };\n    this.onFocus = e => {\n      console.log('Window focused:', e);\n    };\n    this.requestClipboardPermission = async () => {\n      try {\n        const permission = await navigator.permissions.query({\n          name: 'clipboard-read'\n        });\n        if (permission.state === 'granted' || permission.state === 'prompt') {\n          console.log('Clipboard permission granted');\n        } else {\n          console.warn('Clipboard permission denied');\n        }\n      } catch (error) {\n        console.error('Error requesting clipboard permission:', error);\n      }\n    };\n  }\n  startMonitoring(onSuspiciousAddress) {\n    if (this.isMonitoring) {\n      return false;\n    }\n    this.onSuspiciousAddressCallback = onSuspiciousAddress;\n    try {\n      // Add event listeners for clipboard events\n      document.addEventListener('copy', this.handleClipboardEvent);\n      document.addEventListener('cut', this.handleClipboardEvent);\n      document.addEventListener('paste', this.handleClipboardEvent);\n\n      // Set up focus/blur monitoring\n      window.addEventListener('focus', this.onFocus);\n\n      // Request initial clipboard permission\n      this.requestClipboardPermission();\n      this.isMonitoring = true;\n      console.log('Clipboard monitoring started');\n      return true;\n    } catch (error) {\n      console.error('Error starting clipboard monitoring:', error);\n      return false;\n    }\n  }\n  stopMonitoring() {\n    if (!this.isMonitoring) {\n      return;\n    }\n    this.isMonitoring = false;\n\n    // Remove event listeners\n    document.removeEventListener('copy', this.handleClipboardEvent);\n    document.removeEventListener('cut', this.handleClipboardEvent);\n    document.removeEventListener('paste', this.handleClipboardEvent);\n    window.removeEventListener('focus', this.onFocus);\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    console.log('Clipboard monitoring stopped');\n  }\n  isActive() {\n    return this.isMonitoring;\n  }\n  async checkClipboard() {\n    try {\n      const clipboardText = await navigator.clipboard.readText();\n\n      // Only check if clipboard content has changed\n      if (clipboardText !== this.lastClipboardContent) {\n        this.lastClipboardContent = clipboardText;\n\n        // Check for wallet addresses\n        const walletAddresses = this.extractWalletAddresses(clipboardText);\n        for (const address of walletAddresses) {\n          if (this.isSuspiciousAddress(address)) {\n            this.alertSuspiciousAddress(address);\n          }\n        }\n      }\n    } catch (error) {\n      // Clipboard access might be denied or not available\n      console.warn('Could not access clipboard:', error);\n    }\n  }\n  extractWalletAddresses(text) {\n    // Ethereum address pattern (0x followed by 40 hex characters)\n    const ethPattern = /0x[a-fA-F0-9]{40}/g;\n\n    // Bitcoin address patterns\n    const btcLegacyPattern = /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/g;\n    const btcSegwitPattern = /bc1[a-z0-9]{39,59}/g;\n    const addresses = [];\n\n    // Extract Ethereum addresses\n    const ethMatches = text.match(ethPattern);\n    if (ethMatches) {\n      addresses.push(...ethMatches);\n    }\n\n    // Extract Bitcoin addresses (basic validation)\n    const btcLegacyMatches = text.match(btcLegacyPattern);\n    if (btcLegacyMatches) {\n      addresses.push(...btcLegacyMatches.filter(addr => this.isValidBitcoinAddress(addr)));\n    }\n    const btcSegwitMatches = text.match(btcSegwitPattern);\n    if (btcSegwitMatches) {\n      addresses.push(...btcSegwitMatches);\n    }\n    return addresses;\n  }\n  isValidBitcoinAddress(address) {\n    // Basic Bitcoin address validation (simplified)\n    if (address.length < 26 || address.length > 35) {\n      return false;\n    }\n\n    // Check if it starts with valid characters\n    if (!/^[13]/.test(address)) {\n      return false;\n    }\n\n    // Check for invalid characters\n    if (/[0OIl]/.test(address)) {\n      return false;\n    }\n    return true;\n  }\n  isSuspiciousAddress(address) {\n    // Check against known suspicious addresses\n    if (SUSPICIOUS_ADDRESSES.includes(address.toLowerCase())) {\n      return true;\n    }\n\n    // Check against suspicious patterns\n    for (const pattern of SUSPICIOUS_PATTERNS) {\n      if (pattern.test(address)) {\n        return true;\n      }\n    }\n\n    // Additional heuristics for suspicious addresses\n\n    // Check for repeated characters (might indicate test/fake address)\n    const hexPart = address.startsWith('0x') ? address.slice(2) : address;\n    const charCounts = {};\n    for (const char of hexPart) {\n      charCounts[char] = (charCounts[char] || 0) + 1;\n    }\n\n    // If any character appears more than 60% of the time, it's suspicious\n    const maxCount = Math.max(...Object.values(charCounts));\n    if (maxCount > hexPart.length * 0.6) {\n      return true;\n    }\n\n    // Check for sequential patterns\n    if (this.hasSequentialPattern(hexPart)) {\n      return true;\n    }\n    return false;\n  }\n  hasSequentialPattern(hex) {\n    let sequentialCount = 0;\n    for (let i = 1; i < hex.length; i++) {\n      const prev = parseInt(hex[i - 1], 16);\n      const curr = parseInt(hex[i], 16);\n      if (!isNaN(prev) && !isNaN(curr)) {\n        if (Math.abs(curr - prev) === 1) {\n          sequentialCount++;\n          if (sequentialCount >= 4) {\n            // 5 consecutive sequential characters\n            return true;\n          }\n        } else {\n          sequentialCount = 0;\n        }\n      }\n    }\n    return false;\n  }\n  alertSuspiciousAddress(address) {\n    console.warn('ðŸš¨ SUSPICIOUS WALLET ADDRESS DETECTED:', address);\n\n    // Play alert sound\n    if (this.alertSound) {\n      this.alertSound.currentTime = 0;\n      this.alertSound.play().catch(error => {\n        console.warn('Could not play alert sound:', error);\n      });\n    }\n\n    // Call the callback if provided\n    if (this.onSuspiciousAddressCallback) {\n      this.onSuspiciousAddressCallback(address);\n    }\n  }\n\n  // Method to add suspicious addresses dynamically\n  addSuspiciousAddress(address) {\n    if (!SUSPICIOUS_ADDRESSES.includes(address.toLowerCase())) {\n      SUSPICIOUS_ADDRESSES.push(address.toLowerCase());\n    }\n  }\n\n  // Method to get current suspicious addresses (for testing/debugging)\n  getSuspiciousAddresses() {\n    return [...SUSPICIOUS_ADDRESSES];\n  }\n}\n\n// Singleton instance\nexport const clipboardMonitoringService = new ClipboardMonitoringService();","map":{"version":3,"names":["SUSPICIOUS_ADDRESSES","SUSPICIOUS_PATTERNS","ClipboardMonitoringService","constructor","isMonitoring","lastClipboardContent","alertSound","onSuspiciousAddressCallback","pasteHandler","copyHandler","cutHandler","focusHandler","manualCheckInterval","permissionDeniedNotified","handleClipboardEvent","onFocus","requestClipboardPermission","intervalId","Audio","src","e","console","log","type","permission","navigator","permissions","query","name","state","warn","error","startMonitoring","onSuspiciousAddress","document","addEventListener","window","stopMonitoring","removeEventListener","clearInterval","isActive","checkClipboard","clipboardText","clipboard","readText","walletAddresses","extractWalletAddresses","address","isSuspiciousAddress","alertSuspiciousAddress","text","ethPattern","btcLegacyPattern","btcSegwitPattern","addresses","ethMatches","match","push","btcLegacyMatches","filter","addr","isValidBitcoinAddress","btcSegwitMatches","length","test","includes","toLowerCase","pattern","hexPart","startsWith","slice","charCounts","char","maxCount","Math","max","Object","values","hasSequentialPattern","hex","sequentialCount","i","prev","parseInt","curr","isNaN","abs","currentTime","play","catch","addSuspiciousAddress","getSuspiciousAddresses","clipboardMonitoringService"],"sources":["D:/DATA/CAREER/INTERNSHIPS/EMRChains Internship NSTP/PROJECTS/HEALTHCARE_SYSTEM/src/services/clipboardMonitoring.ts"],"sourcesContent":["// Known suspicious/hacked wallet addresses (in a real app, this would be fetched from a security API)\r\nconst SUSPICIOUS_ADDRESSES = [\r\n    '0x1234567890abcdef1234567890abcdef12345678', // Example fake address\r\n    '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef', // Example malicious address\r\n    '0x0000000000000000000000000000000000000000', // Null address\r\n    '0xffffffffffffffffffffffffffffffffffffffff', // Max address (suspicious)\r\n    // Add more known suspicious addresses here\r\n];\r\n\r\n// Common patterns for suspicious addresses\r\nconst SUSPICIOUS_PATTERNS = [\r\n    /^0x0+$/, // All zeros\r\n    /^0xf+$/i, // All Fs\r\n    /^0x(dead|beef|cafe|babe|face)/i, // Common test/fake patterns\r\n    /^0x1234567890abcdef/i, // Sequential pattern\r\n];\r\n\r\nexport class ClipboardMonitoringService {\r\n    private isMonitoring = false;\r\n    private lastClipboardContent = '';\r\n    private alertSound: HTMLAudioElement | null = null;\r\n    private onSuspiciousAddressCallback?: (address: string) => void;\r\n    private pasteHandler: ((e: ClipboardEvent) => void) | null = null;\r\n    private copyHandler: ((e: ClipboardEvent) => void) | null = null;\r\n    private cutHandler: ((e: ClipboardEvent) => void) | null = null;\r\n    private focusHandler: ((e: FocusEvent) => void) | null = null;\r\n    private manualCheckInterval: number | null = null;\r\n    private permissionDeniedNotified = false;\r\n\r\n    // Declare missing properties\r\n    private handleClipboardEvent: (e: ClipboardEvent) => void;\r\n    private onFocus: (e: FocusEvent) => void;\r\n    private requestClipboardPermission: () => Promise<void>;\r\n    private intervalId: number | null = null;\r\n\r\n    constructor() {\r\n        // Create alert sound\r\n        this.alertSound = new Audio();\r\n        // Replace the long base64 string with a shorter valid one for demonstration purposes\r\n        this.alertSound.src = 'data:audio/wav;base64,UklGRh4AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';\r\n\r\n        // Implement missing methods\r\n        this.handleClipboardEvent = (e: ClipboardEvent) => {\r\n            console.log('Clipboard event detected:', e.type);\r\n        };\r\n\r\n        this.onFocus = (e: FocusEvent) => {\r\n            console.log('Window focused:', e);\r\n        };\r\n\r\n        this.requestClipboardPermission = async () => {\r\n            try {\r\n                const permission = await navigator.permissions.query({ name: 'clipboard-read' as PermissionName });\r\n                if (permission.state === 'granted' || permission.state === 'prompt') {\r\n                    console.log('Clipboard permission granted');\r\n                } else {\r\n                    console.warn('Clipboard permission denied');\r\n                }\r\n            } catch (error) {\r\n                console.error('Error requesting clipboard permission:', error);\r\n            }\r\n        };\r\n    }\r\n\r\n    startMonitoring(onSuspiciousAddress?: (address: string) => void): boolean {\r\n        if (this.isMonitoring) {\r\n            return false;\r\n        }\r\n\r\n        this.onSuspiciousAddressCallback = onSuspiciousAddress;\r\n\r\n        try {\r\n            // Add event listeners for clipboard events\r\n            document.addEventListener('copy', this.handleClipboardEvent);\r\n            document.addEventListener('cut', this.handleClipboardEvent);\r\n            document.addEventListener('paste', this.handleClipboardEvent);\r\n\r\n            // Set up focus/blur monitoring\r\n            window.addEventListener('focus', this.onFocus);\r\n\r\n            // Request initial clipboard permission\r\n            this.requestClipboardPermission();\r\n\r\n            this.isMonitoring = true;\r\n            console.log('Clipboard monitoring started');\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error starting clipboard monitoring:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    stopMonitoring(): void {\r\n        if (!this.isMonitoring) {\r\n            return;\r\n        }\r\n\r\n        this.isMonitoring = false;\r\n\r\n        // Remove event listeners\r\n        document.removeEventListener('copy', this.handleClipboardEvent);\r\n        document.removeEventListener('cut', this.handleClipboardEvent);\r\n        document.removeEventListener('paste', this.handleClipboardEvent);\r\n        window.removeEventListener('focus', this.onFocus);\r\n\r\n        if (this.intervalId) {\r\n            clearInterval(this.intervalId);\r\n            this.intervalId = null;\r\n        }\r\n\r\n        console.log('Clipboard monitoring stopped');\r\n    }\r\n\r\n    isActive(): boolean {\r\n        return this.isMonitoring;\r\n    }\r\n\r\n    private async checkClipboard(): Promise<void> {\r\n        try {\r\n            const clipboardText = await navigator.clipboard.readText();\r\n\r\n            // Only check if clipboard content has changed\r\n            if (clipboardText !== this.lastClipboardContent) {\r\n                this.lastClipboardContent = clipboardText;\r\n\r\n                // Check for wallet addresses\r\n                const walletAddresses = this.extractWalletAddresses(clipboardText);\r\n\r\n                for (const address of walletAddresses) {\r\n                    if (this.isSuspiciousAddress(address)) {\r\n                        this.alertSuspiciousAddress(address);\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {\r\n            // Clipboard access might be denied or not available\r\n            console.warn('Could not access clipboard:', error);\r\n        }\r\n    }\r\n\r\n    private extractWalletAddresses(text: string): string[] {\r\n        // Ethereum address pattern (0x followed by 40 hex characters)\r\n        const ethPattern = /0x[a-fA-F0-9]{40}/g;\r\n\r\n        // Bitcoin address patterns\r\n        const btcLegacyPattern = /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/g;\r\n        const btcSegwitPattern = /bc1[a-z0-9]{39,59}/g;\r\n\r\n        const addresses: string[] = [];\r\n\r\n        // Extract Ethereum addresses\r\n        const ethMatches = text.match(ethPattern);\r\n        if (ethMatches) {\r\n            addresses.push(...ethMatches);\r\n        }\r\n\r\n        // Extract Bitcoin addresses (basic validation)\r\n        const btcLegacyMatches = text.match(btcLegacyPattern);\r\n        if (btcLegacyMatches) {\r\n            addresses.push(...btcLegacyMatches.filter(addr => this.isValidBitcoinAddress(addr)));\r\n        }\r\n\r\n        const btcSegwitMatches = text.match(btcSegwitPattern);\r\n        if (btcSegwitMatches) {\r\n            addresses.push(...btcSegwitMatches);\r\n        }\r\n\r\n        return addresses;\r\n    }\r\n\r\n    private isValidBitcoinAddress(address: string): boolean {\r\n        // Basic Bitcoin address validation (simplified)\r\n        if (address.length < 26 || address.length > 35) {\r\n            return false;\r\n        }\r\n\r\n        // Check if it starts with valid characters\r\n        if (!/^[13]/.test(address)) {\r\n            return false;\r\n        }\r\n\r\n        // Check for invalid characters\r\n        if (/[0OIl]/.test(address)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private isSuspiciousAddress(address: string): boolean {\r\n        // Check against known suspicious addresses\r\n        if (SUSPICIOUS_ADDRESSES.includes(address.toLowerCase())) {\r\n            return true;\r\n        }\r\n\r\n        // Check against suspicious patterns\r\n        for (const pattern of SUSPICIOUS_PATTERNS) {\r\n            if (pattern.test(address)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Additional heuristics for suspicious addresses\r\n\r\n        // Check for repeated characters (might indicate test/fake address)\r\n        const hexPart = address.startsWith('0x') ? address.slice(2) : address;\r\n        const charCounts: { [key: string]: number } = {};\r\n        for (const char of hexPart) {\r\n            charCounts[char] = (charCounts[char] || 0) + 1;\r\n        }\r\n\r\n        // If any character appears more than 60% of the time, it's suspicious\r\n        const maxCount = Math.max(...Object.values(charCounts) as number[]);\r\n        if (maxCount > hexPart.length * 0.6) {\r\n            return true;\r\n        }\r\n\r\n        // Check for sequential patterns\r\n        if (this.hasSequentialPattern(hexPart)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private hasSequentialPattern(hex: string): boolean {\r\n        let sequentialCount = 0;\r\n        for (let i = 1; i < hex.length; i++) {\r\n            const prev = parseInt(hex[i - 1], 16);\r\n            const curr = parseInt(hex[i], 16);\r\n\r\n            if (!isNaN(prev) && !isNaN(curr)) {\r\n                if (Math.abs(curr - prev) === 1) {\r\n                    sequentialCount++;\r\n                    if (sequentialCount >= 4) { // 5 consecutive sequential characters\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    sequentialCount = 0;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private alertSuspiciousAddress(address: string): void {\r\n        console.warn('ðŸš¨ SUSPICIOUS WALLET ADDRESS DETECTED:', address);\r\n\r\n        // Play alert sound\r\n        if (this.alertSound) {\r\n            this.alertSound.currentTime = 0;\r\n            this.alertSound.play().catch(error => {\r\n                console.warn('Could not play alert sound:', error);\r\n            });\r\n        }\r\n\r\n        // Call the callback if provided\r\n        if (this.onSuspiciousAddressCallback) {\r\n            this.onSuspiciousAddressCallback(address);\r\n        }\r\n    }\r\n\r\n    // Method to add suspicious addresses dynamically\r\n    addSuspiciousAddress(address: string): void {\r\n        if (!SUSPICIOUS_ADDRESSES.includes(address.toLowerCase())) {\r\n            SUSPICIOUS_ADDRESSES.push(address.toLowerCase());\r\n        }\r\n    }\r\n\r\n    // Method to get current suspicious addresses (for testing/debugging)\r\n    getSuspiciousAddresses(): string[] {\r\n        return [...SUSPICIOUS_ADDRESSES];\r\n    }\r\n}\r\n\r\n// Singleton instance\r\nexport const clipboardMonitoringService = new ClipboardMonitoringService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}