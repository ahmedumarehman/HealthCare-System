{"ast":null,"code":"export class EnhancedBlockchainService {\n  constructor() {\n    this.contractAddresses = {\n      healthRecords: '0x1234567890abcdef1234567890abcdef12345678',\n      nftContract: '0x9876543210fedcba9876543210fedcba98765432',\n      insurance: '0xabcdef1234567890abcdef1234567890abcdef12',\n      dataAccess: '0x5555666677778888999900001111222233334444'\n    };\n    this.networkConfig = {\n      name: 'Ethereum Mainnet',\n      chainId: 1,\n      rpcUrl: 'https://mainnet.infura.io/v3/your-project-id',\n      blockExplorer: 'https://etherscan.io'\n    };\n    this.isConnected = false;\n    this.currentAccount = null;\n  }\n  // Connect to wallet\n  async connectWallet() {\n    try {\n      if (typeof window.ethereum !== 'undefined') {\n        const accounts = await window.ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n        this.currentAccount = accounts[0];\n        this.isConnected = true;\n        return {\n          success: true,\n          account: accounts[0]\n        };\n      } else {\n        // Simulate wallet connection for demo\n        this.currentAccount = '0x742d35cc6cc25532ecd8c2dd1e26d6a78e24b4d4';\n        this.isConnected = true;\n        return {\n          success: true,\n          account: this.currentAccount\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  // Upload file to IPFS (simulated)\n  async uploadToIPFS(file) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const mockHash = `Qm${Math.random().toString(36).substring(2, 34)}`;\n        resolve({\n          hash: mockHash,\n          url: `https://ipfs.io/ipfs/${mockHash}`,\n          size: file.size,\n          type: file.type\n        });\n      }, 2000);\n    });\n  }\n\n  // Store medical record on blockchain\n  async storeHealthRecord(record) {\n    if (!this.isConnected) {\n      throw new Error('Wallet not connected');\n    }\n\n    // Simulate blockchain transaction\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\n        resolve({\n          hash: txHash,\n          from: this.currentAccount,\n          to: this.contractAddresses.healthRecords,\n          value: '0',\n          gasUsed: '21000',\n          gasPrice: '20000000000',\n          blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\n          timestamp: new Date().toISOString(),\n          status: 'confirmed'\n        });\n      }, 3000);\n    });\n  }\n\n  // Mint NFT for health record\n  async mintHealthNFT(record, metadata) {\n    if (!this.isConnected) {\n      throw new Error('Wallet not connected');\n    }\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const tokenId = `HEALTH-NFT-${Date.now()}`;\n        const nft = {\n          id: `nft-${Date.now()}`,\n          tokenId,\n          patientId: record.patientId,\n          recordId: record.id,\n          name: `${record.title} - NFT`,\n          description: `Blockchain-verified health record: ${record.description}`,\n          imageUrl: `https://via.placeholder.com/400x400/4F46E5/FFFFFF?text=${tokenId}`,\n          metadataUri: `ipfs://Qm${Math.random().toString(36).substring(2, 34)}`,\n          contractAddress: this.contractAddresses.nftContract,\n          blockchainNetwork: 'Ethereum',\n          mintDate: new Date().toISOString(),\n          currentOwner: record.patientId,\n          isTransferable: false,\n          accessLevel: 'patient_doctor'\n        };\n        resolve(nft);\n      }, 4000);\n    });\n  }\n\n  // Create smart contract for data access\n  async createDataAccessContract(patientId, doctorId, recordIds, expiryDate) {\n    if (!this.isConnected) {\n      throw new Error('Wallet not connected');\n    }\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const contract = {\n          id: `contract-${Date.now()}`,\n          address: `0x${Math.random().toString(16).substring(2, 42)}`,\n          type: 'data_access',\n          creator: patientId,\n          participants: [patientId, doctorId],\n          terms: {\n            accessScope: recordIds,\n            expiryDate,\n            purpose: 'Medical consultation and treatment'\n          },\n          status: 'active',\n          createdAt: new Date().toISOString(),\n          blockchainTxId: `0x${Math.random().toString(16).substring(2, 66)}`,\n          isExecuted: false\n        };\n        resolve(contract);\n      }, 2500);\n    });\n  }\n\n  // Process insurance claim on blockchain\n  async processInsuranceClaim(claim) {\n    if (!this.isConnected) {\n      throw new Error('Wallet not connected');\n    }\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\n        resolve({\n          hash: txHash,\n          from: this.currentAccount,\n          to: this.contractAddresses.insurance,\n          value: claim.amount.toString(),\n          gasUsed: '45000',\n          gasPrice: '25000000000',\n          blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\n          timestamp: new Date().toISOString(),\n          status: 'confirmed'\n        });\n      }, 3500);\n    });\n  }\n\n  // Verify record integrity\n  async verifyRecordIntegrity(record) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        // Simulate verification process\n        const isValid = Math.random() > 0.1; // 90% success rate\n        resolve({\n          isValid,\n          details: isValid ? 'Record hash matches blockchain data. Integrity verified.' : 'Warning: Record hash mismatch detected. Data may have been tampered with.'\n        });\n      }, 1500);\n    });\n  }\n\n  // Get transaction details\n  async getTransactionDetails(txHash) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        if (Math.random() > 0.2) {\n          // 80% success rate\n          resolve({\n            hash: txHash,\n            from: '0x1234567890abcdef1234567890abcdef12345678',\n            to: '0x9876543210fedcba9876543210fedcba98765432',\n            value: '0',\n            gasUsed: '21000',\n            gasPrice: '20000000000',\n            blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\n            timestamp: new Date().toISOString(),\n            status: 'confirmed'\n          });\n        } else {\n          resolve(null);\n        }\n      }, 1000);\n    });\n  }\n\n  // Grant/revoke data access\n  async updateDataAccess(patientId, providerId, recordIds, action) {\n    if (!this.isConnected) {\n      throw new Error('Wallet not connected');\n    }\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\n        resolve({\n          hash: txHash,\n          from: this.currentAccount,\n          to: this.contractAddresses.dataAccess,\n          value: '0',\n          gasUsed: '35000',\n          gasPrice: '22000000000',\n          blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\n          timestamp: new Date().toISOString(),\n          status: 'confirmed'\n        });\n      }, 2000);\n    });\n  }\n\n  // Get NFT metadata\n  async getNFTMetadata(tokenId) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve({\n          name: `Health Record NFT #${tokenId}`,\n          description: 'Blockchain-verified medical record',\n          image: `https://via.placeholder.com/400x400/4F46E5/FFFFFF?text=${tokenId}`,\n          attributes: [{\n            trait_type: 'Record Type',\n            value: 'Medical Examination'\n          }, {\n            trait_type: 'Verification',\n            value: 'Blockchain Verified'\n          }, {\n            trait_type: 'Privacy',\n            value: 'HIPAA Compliant'\n          }, {\n            trait_type: 'Network',\n            value: 'Ethereum'\n          }],\n          properties: {\n            date: new Date().toISOString(),\n            encrypted: true,\n            transferable: false\n          }\n        });\n      }, 1000);\n    });\n  }\n\n  // Get network stats\n  getNetworkInfo() {\n    return {\n      ...this.networkConfig,\n      isConnected: this.isConnected,\n      currentAccount: this.currentAccount,\n      contractAddresses: this.contractAddresses\n    };\n  }\n\n  // Estimate gas for transaction\n  async estimateGas(operation) {\n    const gasEstimates = {\n      store_record: {\n        gasLimit: '21000',\n        gasPrice: '20000000000'\n      },\n      mint_nft: {\n        gasLimit: '85000',\n        gasPrice: '25000000000'\n      },\n      access_grant: {\n        gasLimit: '35000',\n        gasPrice: '22000000000'\n      },\n      insurance_claim: {\n        gasLimit: '45000',\n        gasPrice: '25000000000'\n      }\n    };\n    const estimate = gasEstimates[operation];\n    const costInWei = BigInt(estimate.gasLimit) * BigInt(estimate.gasPrice);\n    const costInEth = (Number(costInWei) / 1e18).toFixed(6);\n    return {\n      ...estimate,\n      estimatedCost: `${costInEth} ETH`\n    };\n  }\n\n  // Disconnect wallet\n  disconnect() {\n    this.isConnected = false;\n    this.currentAccount = null;\n  }\n}\nexport default EnhancedBlockchainService;","map":{"version":3,"names":["EnhancedBlockchainService","constructor","contractAddresses","healthRecords","nftContract","insurance","dataAccess","networkConfig","name","chainId","rpcUrl","blockExplorer","isConnected","currentAccount","connectWallet","window","ethereum","accounts","request","method","success","account","error","Error","message","uploadToIPFS","file","Promise","resolve","setTimeout","mockHash","Math","random","toString","substring","hash","url","size","type","storeHealthRecord","record","txHash","from","to","value","gasUsed","gasPrice","blockNumber","floor","timestamp","Date","toISOString","status","mintHealthNFT","metadata","tokenId","now","nft","id","patientId","recordId","title","description","imageUrl","metadataUri","contractAddress","blockchainNetwork","mintDate","currentOwner","isTransferable","accessLevel","createDataAccessContract","doctorId","recordIds","expiryDate","contract","address","creator","participants","terms","accessScope","purpose","createdAt","blockchainTxId","isExecuted","processInsuranceClaim","claim","amount","verifyRecordIntegrity","isValid","details","getTransactionDetails","updateDataAccess","providerId","action","getNFTMetadata","image","attributes","trait_type","properties","date","encrypted","transferable","getNetworkInfo","estimateGas","operation","gasEstimates","store_record","gasLimit","mint_nft","access_grant","insurance_claim","estimate","costInWei","BigInt","costInEth","Number","toFixed","estimatedCost","disconnect"],"sources":["D:/DATA/CAREER/INTERNSHIPS/EMRChains Internship NSTP/PROJECTS/HEALTHCARE_SYSTEM/src/services/enhancedBlockchain.ts"],"sourcesContent":["import { User, MedicalRecord, NFTHealthRecord, InsuranceClaim, SmartContract } from '../types';\r\n\r\nexport interface BlockchainTransaction {\r\n    hash: string;\r\n    from: string;\r\n    to: string;\r\n    value: string;\r\n    gasUsed: string;\r\n    gasPrice: string;\r\n    blockNumber: number;\r\n    timestamp: string;\r\n    status: 'pending' | 'confirmed' | 'failed';\r\n}\r\n\r\nexport interface IPFSUploadResult {\r\n    hash: string;\r\n    url: string;\r\n    size: number;\r\n    type: string;\r\n}\r\n\r\nexport class EnhancedBlockchainService {\r\n    private readonly contractAddresses = {\r\n        healthRecords: '0x1234567890abcdef1234567890abcdef12345678',\r\n        nftContract: '0x9876543210fedcba9876543210fedcba98765432',\r\n        insurance: '0xabcdef1234567890abcdef1234567890abcdef12',\r\n        dataAccess: '0x5555666677778888999900001111222233334444'\r\n    };\r\n\r\n    private readonly networkConfig = {\r\n        name: 'Ethereum Mainnet',\r\n        chainId: 1,\r\n        rpcUrl: 'https://mainnet.infura.io/v3/your-project-id',\r\n        blockExplorer: 'https://etherscan.io'\r\n    };\r\n\r\n    private isConnected = false;\r\n    private currentAccount: string | null = null;\r\n\r\n    // Connect to wallet\r\n    async connectWallet(): Promise<{ success: boolean; account?: string; error?: string }> {\r\n        try {\r\n            if (typeof window.ethereum !== 'undefined') {\r\n                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\r\n                this.currentAccount = accounts[0];\r\n                this.isConnected = true;\r\n                return { success: true, account: accounts[0] };\r\n            } else {\r\n                // Simulate wallet connection for demo\r\n                this.currentAccount = '0x742d35cc6cc25532ecd8c2dd1e26d6a78e24b4d4';\r\n                this.isConnected = true;\r\n                return { success: true, account: this.currentAccount };\r\n            }\r\n        } catch (error) {\r\n            return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\r\n        }\r\n    }\r\n\r\n    // Upload file to IPFS (simulated)\r\n    async uploadToIPFS(file: File): Promise<IPFSUploadResult> {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const mockHash = `Qm${Math.random().toString(36).substring(2, 34)}`;\r\n                resolve({\r\n                    hash: mockHash,\r\n                    url: `https://ipfs.io/ipfs/${mockHash}`,\r\n                    size: file.size,\r\n                    type: file.type\r\n                });\r\n            }, 2000);\r\n        });\r\n    }\r\n\r\n    // Store medical record on blockchain\r\n    async storeHealthRecord(record: MedicalRecord): Promise<BlockchainTransaction> {\r\n        if (!this.isConnected) {\r\n            throw new Error('Wallet not connected');\r\n        }\r\n\r\n        // Simulate blockchain transaction\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\r\n                resolve({\r\n                    hash: txHash,\r\n                    from: this.currentAccount!,\r\n                    to: this.contractAddresses.healthRecords,\r\n                    value: '0',\r\n                    gasUsed: '21000',\r\n                    gasPrice: '20000000000',\r\n                    blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\r\n                    timestamp: new Date().toISOString(),\r\n                    status: 'confirmed'\r\n                });\r\n            }, 3000);\r\n        });\r\n    }\r\n\r\n    // Mint NFT for health record\r\n    async mintHealthNFT(record: MedicalRecord, metadata: any): Promise<NFTHealthRecord> {\r\n        if (!this.isConnected) {\r\n            throw new Error('Wallet not connected');\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const tokenId = `HEALTH-NFT-${Date.now()}`;\r\n                const nft: NFTHealthRecord = {\r\n                    id: `nft-${Date.now()}`,\r\n                    tokenId,\r\n                    patientId: record.patientId,\r\n                    recordId: record.id,\r\n                    name: `${record.title} - NFT`,\r\n                    description: `Blockchain-verified health record: ${record.description}`,\r\n                    imageUrl: `https://via.placeholder.com/400x400/4F46E5/FFFFFF?text=${tokenId}`,\r\n                    metadataUri: `ipfs://Qm${Math.random().toString(36).substring(2, 34)}`,\r\n                    contractAddress: this.contractAddresses.nftContract,\r\n                    blockchainNetwork: 'Ethereum',\r\n                    mintDate: new Date().toISOString(),\r\n                    currentOwner: record.patientId,\r\n                    isTransferable: false,\r\n                    accessLevel: 'patient_doctor'\r\n                };\r\n                resolve(nft);\r\n            }, 4000);\r\n        });\r\n    }\r\n\r\n    // Create smart contract for data access\r\n    async createDataAccessContract(\r\n        patientId: string,\r\n        doctorId: string,\r\n        recordIds: string[],\r\n        expiryDate: string\r\n    ): Promise<SmartContract> {\r\n        if (!this.isConnected) {\r\n            throw new Error('Wallet not connected');\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const contract: SmartContract = {\r\n                    id: `contract-${Date.now()}`,\r\n                    address: `0x${Math.random().toString(16).substring(2, 42)}`,\r\n                    type: 'data_access',\r\n                    creator: patientId,\r\n                    participants: [patientId, doctorId],\r\n                    terms: {\r\n                        accessScope: recordIds,\r\n                        expiryDate,\r\n                        purpose: 'Medical consultation and treatment'\r\n                    },\r\n                    status: 'active',\r\n                    createdAt: new Date().toISOString(),\r\n                    blockchainTxId: `0x${Math.random().toString(16).substring(2, 66)}`,\r\n                    isExecuted: false\r\n                };\r\n                resolve(contract);\r\n            }, 2500);\r\n        });\r\n    }\r\n\r\n    // Process insurance claim on blockchain\r\n    async processInsuranceClaim(claim: InsuranceClaim): Promise<BlockchainTransaction> {\r\n        if (!this.isConnected) {\r\n            throw new Error('Wallet not connected');\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\r\n                resolve({\r\n                    hash: txHash,\r\n                    from: this.currentAccount!,\r\n                    to: this.contractAddresses.insurance,\r\n                    value: claim.amount.toString(),\r\n                    gasUsed: '45000',\r\n                    gasPrice: '25000000000',\r\n                    blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\r\n                    timestamp: new Date().toISOString(),\r\n                    status: 'confirmed'\r\n                });\r\n            }, 3500);\r\n        });\r\n    }\r\n\r\n    // Verify record integrity\r\n    async verifyRecordIntegrity(record: MedicalRecord): Promise<{ isValid: boolean; details: string }> {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                // Simulate verification process\r\n                const isValid = Math.random() > 0.1; // 90% success rate\r\n                resolve({\r\n                    isValid,\r\n                    details: isValid\r\n                        ? 'Record hash matches blockchain data. Integrity verified.'\r\n                        : 'Warning: Record hash mismatch detected. Data may have been tampered with.'\r\n                });\r\n            }, 1500);\r\n        });\r\n    }\r\n\r\n    // Get transaction details\r\n    async getTransactionDetails(txHash: string): Promise<BlockchainTransaction | null> {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                if (Math.random() > 0.2) { // 80% success rate\r\n                    resolve({\r\n                        hash: txHash,\r\n                        from: '0x1234567890abcdef1234567890abcdef12345678',\r\n                        to: '0x9876543210fedcba9876543210fedcba98765432',\r\n                        value: '0',\r\n                        gasUsed: '21000',\r\n                        gasPrice: '20000000000',\r\n                        blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\r\n                        timestamp: new Date().toISOString(),\r\n                        status: 'confirmed'\r\n                    });\r\n                } else {\r\n                    resolve(null);\r\n                }\r\n            }, 1000);\r\n        });\r\n    }\r\n\r\n    // Grant/revoke data access\r\n    async updateDataAccess(\r\n        patientId: string,\r\n        providerId: string,\r\n        recordIds: string[],\r\n        action: 'grant' | 'revoke'\r\n    ): Promise<BlockchainTransaction> {\r\n        if (!this.isConnected) {\r\n            throw new Error('Wallet not connected');\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                const txHash = `0x${Math.random().toString(16).substring(2, 66)}`;\r\n                resolve({\r\n                    hash: txHash,\r\n                    from: this.currentAccount!,\r\n                    to: this.contractAddresses.dataAccess,\r\n                    value: '0',\r\n                    gasUsed: '35000',\r\n                    gasPrice: '22000000000',\r\n                    blockNumber: Math.floor(Math.random() * 1000000) + 18000000,\r\n                    timestamp: new Date().toISOString(),\r\n                    status: 'confirmed'\r\n                });\r\n            }, 2000);\r\n        });\r\n    }\r\n\r\n    // Get NFT metadata\r\n    async getNFTMetadata(tokenId: string): Promise<any> {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                resolve({\r\n                    name: `Health Record NFT #${tokenId}`,\r\n                    description: 'Blockchain-verified medical record',\r\n                    image: `https://via.placeholder.com/400x400/4F46E5/FFFFFF?text=${tokenId}`,\r\n                    attributes: [\r\n                        { trait_type: 'Record Type', value: 'Medical Examination' },\r\n                        { trait_type: 'Verification', value: 'Blockchain Verified' },\r\n                        { trait_type: 'Privacy', value: 'HIPAA Compliant' },\r\n                        { trait_type: 'Network', value: 'Ethereum' }\r\n                    ],\r\n                    properties: {\r\n                        date: new Date().toISOString(),\r\n                        encrypted: true,\r\n                        transferable: false\r\n                    }\r\n                });\r\n            }, 1000);\r\n        });\r\n    }\r\n\r\n    // Get network stats\r\n    getNetworkInfo() {\r\n        return {\r\n            ...this.networkConfig,\r\n            isConnected: this.isConnected,\r\n            currentAccount: this.currentAccount,\r\n            contractAddresses: this.contractAddresses\r\n        };\r\n    }\r\n\r\n    // Estimate gas for transaction\r\n    async estimateGas(operation: 'store_record' | 'mint_nft' | 'access_grant' | 'insurance_claim'): Promise<{\r\n        gasLimit: string;\r\n        gasPrice: string;\r\n        estimatedCost: string;\r\n    }> {\r\n        const gasEstimates = {\r\n            store_record: { gasLimit: '21000', gasPrice: '20000000000' },\r\n            mint_nft: { gasLimit: '85000', gasPrice: '25000000000' },\r\n            access_grant: { gasLimit: '35000', gasPrice: '22000000000' },\r\n            insurance_claim: { gasLimit: '45000', gasPrice: '25000000000' }\r\n        };\r\n\r\n        const estimate = gasEstimates[operation];\r\n        const costInWei = BigInt(estimate.gasLimit) * BigInt(estimate.gasPrice);\r\n        const costInEth = (Number(costInWei) / 1e18).toFixed(6);\r\n\r\n        return {\r\n            ...estimate,\r\n            estimatedCost: `${costInEth} ETH`\r\n        };\r\n    }\r\n\r\n    // Disconnect wallet\r\n    disconnect() {\r\n        this.isConnected = false;\r\n        this.currentAccount = null;\r\n    }\r\n}\r\n\r\nexport default EnhancedBlockchainService;\r\n"],"mappings":"AAqBA,OAAO,MAAMA,yBAAyB,CAAC;EAAAC,YAAA;IAAA,KAClBC,iBAAiB,GAAG;MACjCC,aAAa,EAAE,4CAA4C;MAC3DC,WAAW,EAAE,4CAA4C;MACzDC,SAAS,EAAE,4CAA4C;MACvDC,UAAU,EAAE;IAChB,CAAC;IAAA,KAEgBC,aAAa,GAAG;MAC7BC,IAAI,EAAE,kBAAkB;MACxBC,OAAO,EAAE,CAAC;MACVC,MAAM,EAAE,8CAA8C;MACtDC,aAAa,EAAE;IACnB,CAAC;IAAA,KAEOC,WAAW,GAAG,KAAK;IAAA,KACnBC,cAAc,GAAkB,IAAI;EAAA;EAE5C;EACA,MAAMC,aAAaA,CAAA,EAAoE;IACnF,IAAI;MACA,IAAI,OAAOC,MAAM,CAACC,QAAQ,KAAK,WAAW,EAAE;QACxC,MAAMC,QAAQ,GAAG,MAAMF,MAAM,CAACC,QAAQ,CAACE,OAAO,CAAC;UAAEC,MAAM,EAAE;QAAsB,CAAC,CAAC;QACjF,IAAI,CAACN,cAAc,GAAGI,QAAQ,CAAC,CAAC,CAAC;QACjC,IAAI,CAACL,WAAW,GAAG,IAAI;QACvB,OAAO;UAAEQ,OAAO,EAAE,IAAI;UAAEC,OAAO,EAAEJ,QAAQ,CAAC,CAAC;QAAE,CAAC;MAClD,CAAC,MAAM;QACH;QACA,IAAI,CAACJ,cAAc,GAAG,4CAA4C;QAClE,IAAI,CAACD,WAAW,GAAG,IAAI;QACvB,OAAO;UAAEQ,OAAO,EAAE,IAAI;UAAEC,OAAO,EAAE,IAAI,CAACR;QAAe,CAAC;MAC1D;IACJ,CAAC,CAAC,OAAOS,KAAK,EAAE;MACZ,OAAO;QAAEF,OAAO,EAAE,KAAK;QAAEE,KAAK,EAAEA,KAAK,YAAYC,KAAK,GAAGD,KAAK,CAACE,OAAO,GAAG;MAAgB,CAAC;IAC9F;EACJ;;EAEA;EACA,MAAMC,YAAYA,CAACC,IAAU,EAA6B;IACtD,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAMC,QAAQ,GAAG,KAAKC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;QACnEN,OAAO,CAAC;UACJO,IAAI,EAAEL,QAAQ;UACdM,GAAG,EAAE,wBAAwBN,QAAQ,EAAE;UACvCO,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfC,IAAI,EAAEZ,IAAI,CAACY;QACf,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMC,iBAAiBA,CAACC,MAAqB,EAAkC;IAC3E,IAAI,CAAC,IAAI,CAAC5B,WAAW,EAAE;MACnB,MAAM,IAAIW,KAAK,CAAC,sBAAsB,CAAC;IAC3C;;IAEA;IACA,OAAO,IAAII,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAMY,MAAM,GAAG,KAAKV,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;QACjEN,OAAO,CAAC;UACJO,IAAI,EAAEM,MAAM;UACZC,IAAI,EAAE,IAAI,CAAC7B,cAAe;UAC1B8B,EAAE,EAAE,IAAI,CAACzC,iBAAiB,CAACC,aAAa;UACxCyC,KAAK,EAAE,GAAG;UACVC,OAAO,EAAE,OAAO;UAChBC,QAAQ,EAAE,aAAa;UACvBC,WAAW,EAAEhB,IAAI,CAACiB,KAAK,CAACjB,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,QAAQ;UAC3DiB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCC,MAAM,EAAE;QACZ,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMC,aAAaA,CAACb,MAAqB,EAAEc,QAAa,EAA4B;IAChF,IAAI,CAAC,IAAI,CAAC1C,WAAW,EAAE;MACnB,MAAM,IAAIW,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IAEA,OAAO,IAAII,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAM0B,OAAO,GAAG,cAAcL,IAAI,CAACM,GAAG,CAAC,CAAC,EAAE;QAC1C,MAAMC,GAAoB,GAAG;UACzBC,EAAE,EAAE,OAAOR,IAAI,CAACM,GAAG,CAAC,CAAC,EAAE;UACvBD,OAAO;UACPI,SAAS,EAAEnB,MAAM,CAACmB,SAAS;UAC3BC,QAAQ,EAAEpB,MAAM,CAACkB,EAAE;UACnBlD,IAAI,EAAE,GAAGgC,MAAM,CAACqB,KAAK,QAAQ;UAC7BC,WAAW,EAAE,sCAAsCtB,MAAM,CAACsB,WAAW,EAAE;UACvEC,QAAQ,EAAE,0DAA0DR,OAAO,EAAE;UAC7ES,WAAW,EAAE,YAAYjC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;UACtE+B,eAAe,EAAE,IAAI,CAAC/D,iBAAiB,CAACE,WAAW;UACnD8D,iBAAiB,EAAE,UAAU;UAC7BC,QAAQ,EAAE,IAAIjB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UAClCiB,YAAY,EAAE5B,MAAM,CAACmB,SAAS;UAC9BU,cAAc,EAAE,KAAK;UACrBC,WAAW,EAAE;QACjB,CAAC;QACD1C,OAAO,CAAC6B,GAAG,CAAC;MAChB,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMc,wBAAwBA,CAC1BZ,SAAiB,EACjBa,QAAgB,EAChBC,SAAmB,EACnBC,UAAkB,EACI;IACtB,IAAI,CAAC,IAAI,CAAC9D,WAAW,EAAE;MACnB,MAAM,IAAIW,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IAEA,OAAO,IAAII,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAM8C,QAAuB,GAAG;UAC5BjB,EAAE,EAAE,YAAYR,IAAI,CAACM,GAAG,CAAC,CAAC,EAAE;UAC5BoB,OAAO,EAAE,KAAK7C,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;UAC3DI,IAAI,EAAE,aAAa;UACnBuC,OAAO,EAAElB,SAAS;UAClBmB,YAAY,EAAE,CAACnB,SAAS,EAAEa,QAAQ,CAAC;UACnCO,KAAK,EAAE;YACHC,WAAW,EAAEP,SAAS;YACtBC,UAAU;YACVO,OAAO,EAAE;UACb,CAAC;UACD7B,MAAM,EAAE,QAAQ;UAChB8B,SAAS,EAAE,IAAIhC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCgC,cAAc,EAAE,KAAKpD,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;UAClEkD,UAAU,EAAE;QAChB,CAAC;QACDxD,OAAO,CAAC+C,QAAQ,CAAC;MACrB,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMU,qBAAqBA,CAACC,KAAqB,EAAkC;IAC/E,IAAI,CAAC,IAAI,CAAC1E,WAAW,EAAE;MACnB,MAAM,IAAIW,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IAEA,OAAO,IAAII,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAMY,MAAM,GAAG,KAAKV,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;QACjEN,OAAO,CAAC;UACJO,IAAI,EAAEM,MAAM;UACZC,IAAI,EAAE,IAAI,CAAC7B,cAAe;UAC1B8B,EAAE,EAAE,IAAI,CAACzC,iBAAiB,CAACG,SAAS;UACpCuC,KAAK,EAAE0C,KAAK,CAACC,MAAM,CAACtD,QAAQ,CAAC,CAAC;UAC9BY,OAAO,EAAE,OAAO;UAChBC,QAAQ,EAAE,aAAa;UACvBC,WAAW,EAAEhB,IAAI,CAACiB,KAAK,CAACjB,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,QAAQ;UAC3DiB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCC,MAAM,EAAE;QACZ,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMoC,qBAAqBA,CAAChD,MAAqB,EAAkD;IAC/F,OAAO,IAAIb,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb;QACA,MAAM4D,OAAO,GAAG1D,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;QACrCJ,OAAO,CAAC;UACJ6D,OAAO;UACPC,OAAO,EAAED,OAAO,GACV,0DAA0D,GAC1D;QACV,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAME,qBAAqBA,CAAClD,MAAc,EAAyC;IAC/E,OAAO,IAAId,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,IAAIE,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,EAAE;UAAE;UACvBJ,OAAO,CAAC;YACJO,IAAI,EAAEM,MAAM;YACZC,IAAI,EAAE,4CAA4C;YAClDC,EAAE,EAAE,4CAA4C;YAChDC,KAAK,EAAE,GAAG;YACVC,OAAO,EAAE,OAAO;YAChBC,QAAQ,EAAE,aAAa;YACvBC,WAAW,EAAEhB,IAAI,CAACiB,KAAK,CAACjB,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,QAAQ;YAC3DiB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YACnCC,MAAM,EAAE;UACZ,CAAC,CAAC;QACN,CAAC,MAAM;UACHxB,OAAO,CAAC,IAAI,CAAC;QACjB;MACJ,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAMgE,gBAAgBA,CAClBjC,SAAiB,EACjBkC,UAAkB,EAClBpB,SAAmB,EACnBqB,MAA0B,EACI;IAC9B,IAAI,CAAC,IAAI,CAAClF,WAAW,EAAE;MACnB,MAAM,IAAIW,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IAEA,OAAO,IAAII,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACb,MAAMY,MAAM,GAAG,KAAKV,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;QACjEN,OAAO,CAAC;UACJO,IAAI,EAAEM,MAAM;UACZC,IAAI,EAAE,IAAI,CAAC7B,cAAe;UAC1B8B,EAAE,EAAE,IAAI,CAACzC,iBAAiB,CAACI,UAAU;UACrCsC,KAAK,EAAE,GAAG;UACVC,OAAO,EAAE,OAAO;UAChBC,QAAQ,EAAE,aAAa;UACvBC,WAAW,EAAEhB,IAAI,CAACiB,KAAK,CAACjB,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,QAAQ;UAC3DiB,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;UACnCC,MAAM,EAAE;QACZ,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,MAAM2C,cAAcA,CAACxC,OAAe,EAAgB;IAChD,OAAO,IAAI5B,OAAO,CAAEC,OAAO,IAAK;MAC5BC,UAAU,CAAC,MAAM;QACbD,OAAO,CAAC;UACJpB,IAAI,EAAE,sBAAsB+C,OAAO,EAAE;UACrCO,WAAW,EAAE,oCAAoC;UACjDkC,KAAK,EAAE,0DAA0DzC,OAAO,EAAE;UAC1E0C,UAAU,EAAE,CACR;YAAEC,UAAU,EAAE,aAAa;YAAEtD,KAAK,EAAE;UAAsB,CAAC,EAC3D;YAAEsD,UAAU,EAAE,cAAc;YAAEtD,KAAK,EAAE;UAAsB,CAAC,EAC5D;YAAEsD,UAAU,EAAE,SAAS;YAAEtD,KAAK,EAAE;UAAkB,CAAC,EACnD;YAAEsD,UAAU,EAAE,SAAS;YAAEtD,KAAK,EAAE;UAAW,CAAC,CAC/C;UACDuD,UAAU,EAAE;YACRC,IAAI,EAAE,IAAIlD,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;YAC9BkD,SAAS,EAAE,IAAI;YACfC,YAAY,EAAE;UAClB;QACJ,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC,CAAC;EACN;;EAEA;EACAC,cAAcA,CAAA,EAAG;IACb,OAAO;MACH,GAAG,IAAI,CAAChG,aAAa;MACrBK,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,cAAc,EAAE,IAAI,CAACA,cAAc;MACnCX,iBAAiB,EAAE,IAAI,CAACA;IAC5B,CAAC;EACL;;EAEA;EACA,MAAMsG,WAAWA,CAACC,SAA2E,EAI1F;IACC,MAAMC,YAAY,GAAG;MACjBC,YAAY,EAAE;QAAEC,QAAQ,EAAE,OAAO;QAAE9D,QAAQ,EAAE;MAAc,CAAC;MAC5D+D,QAAQ,EAAE;QAAED,QAAQ,EAAE,OAAO;QAAE9D,QAAQ,EAAE;MAAc,CAAC;MACxDgE,YAAY,EAAE;QAAEF,QAAQ,EAAE,OAAO;QAAE9D,QAAQ,EAAE;MAAc,CAAC;MAC5DiE,eAAe,EAAE;QAAEH,QAAQ,EAAE,OAAO;QAAE9D,QAAQ,EAAE;MAAc;IAClE,CAAC;IAED,MAAMkE,QAAQ,GAAGN,YAAY,CAACD,SAAS,CAAC;IACxC,MAAMQ,SAAS,GAAGC,MAAM,CAACF,QAAQ,CAACJ,QAAQ,CAAC,GAAGM,MAAM,CAACF,QAAQ,CAAClE,QAAQ,CAAC;IACvE,MAAMqE,SAAS,GAAG,CAACC,MAAM,CAACH,SAAS,CAAC,GAAG,IAAI,EAAEI,OAAO,CAAC,CAAC,CAAC;IAEvD,OAAO;MACH,GAAGL,QAAQ;MACXM,aAAa,EAAE,GAAGH,SAAS;IAC/B,CAAC;EACL;;EAEA;EACAI,UAAUA,CAAA,EAAG;IACT,IAAI,CAAC3G,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,cAAc,GAAG,IAAI;EAC9B;AACJ;AAEA,eAAeb,yBAAyB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}