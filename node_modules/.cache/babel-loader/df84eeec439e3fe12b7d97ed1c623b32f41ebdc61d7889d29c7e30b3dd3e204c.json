{"ast":null,"code":"import CryptoJS from 'crypto-js';\nexport class EncryptionService {\n  constructor() {\n    this.secretKey = void 0;\n    // In production, this should come from environment variables\n    this.secretKey = process.env.REACT_APP_ENCRYPTION_KEY || 'default-secret-key';\n  }\n  encryptData(data) {\n    try {\n      const encrypted = CryptoJS.AES.encrypt(data, this.secretKey).toString();\n      return encrypted;\n    } catch (error) {\n      console.error('Encryption failed:', error);\n      throw new Error('Failed to encrypt data');\n    }\n  }\n  decryptData(encryptedData) {\n    try {\n      const bytes = CryptoJS.AES.decrypt(encryptedData, this.secretKey);\n      const decrypted = bytes.toString(CryptoJS.enc.Utf8);\n      if (!decrypted) {\n        throw new Error('Failed to decrypt data - invalid key or corrupted data');\n      }\n      return decrypted;\n    } catch (error) {\n      console.error('Decryption failed:', error);\n      throw new Error('Failed to decrypt data');\n    }\n  }\n\n  // Enhanced encryption with password and verification\n  encryptWithPassword(data, password) {\n    try {\n      const salt = CryptoJS.lib.WordArray.random(128 / 8).toString();\n      const key = this.deriveKey(password, salt);\n      const verification = CryptoJS.SHA256(password + salt).toString();\n      const dataWithVerification = JSON.stringify({\n        verification: verification,\n        originalData: data\n      });\n      const encryptedData = CryptoJS.AES.encrypt(dataWithVerification, key).toString();\n      return {\n        encryptedData,\n        salt,\n        verification\n      };\n    } catch (error) {\n      console.error('Password encryption failed:', error);\n      throw new Error('Failed to encrypt data with password');\n    }\n  }\n\n  // Enhanced decryption with password verification\n  decryptWithPassword(encryptedData, password, salt, expectedVerification) {\n    try {\n      const key = this.deriveKey(password, salt);\n      const passwordVerification = CryptoJS.SHA256(password + salt).toString();\n      const bytes = CryptoJS.AES.decrypt(encryptedData, key);\n      const decryptedString = bytes.toString(CryptoJS.enc.Utf8);\n      if (!decryptedString) {\n        throw new Error('Invalid password - decryption resulted in empty data');\n      }\n      let decryptedData;\n      try {\n        decryptedData = JSON.parse(decryptedString);\n      } catch (error) {\n        throw new Error('Invalid password or corrupted data - unable to parse decrypted content');\n      }\n\n      // Verify the password using the embedded verification hash\n      if (decryptedData.verification) {\n        if (decryptedData.verification !== passwordVerification) {\n          throw new Error('Invalid password - verification failed');\n        }\n        return decryptedData.originalData;\n      } else if (expectedVerification) {\n        if (expectedVerification !== passwordVerification) {\n          throw new Error('Invalid password - verification failed');\n        }\n        return decryptedString;\n      } else {\n        console.warn('Decryption performed without password verification');\n        return decryptedString;\n      }\n    } catch (error) {\n      console.error('Password decryption failed:', error);\n      if (error instanceof Error && error.message.includes('Invalid password')) {\n        throw error;\n      }\n      throw new Error('Failed to decrypt data with password');\n    }\n  }\n  hashData(data) {\n    return CryptoJS.SHA256(data).toString();\n  }\n  generateSalt() {\n    return CryptoJS.lib.WordArray.random(128 / 8).toString();\n  }\n  deriveKey(password, salt) {\n    return CryptoJS.PBKDF2(password, salt, {\n      keySize: 256 / 32,\n      iterations: 100000\n    }).toString();\n  }\n  encryptMedicalRecord(record) {\n    const jsonData = JSON.stringify(record);\n    const encryptedData = this.encryptData(jsonData);\n    const hash = this.hashData(jsonData);\n    return {\n      encryptedData,\n      hash\n    };\n  }\n  decryptMedicalRecord(encryptedData) {\n    const decryptedJson = this.decryptData(encryptedData);\n    return JSON.parse(decryptedJson);\n  }\n  verifyRecordIntegrity(record, expectedHash) {\n    const currentHash = this.hashData(JSON.stringify(record));\n    return currentHash === expectedHash;\n  }\n}\nexport const encryptionService = new EncryptionService();","map":{"version":3,"names":["CryptoJS","EncryptionService","constructor","secretKey","process","env","REACT_APP_ENCRYPTION_KEY","encryptData","data","encrypted","AES","encrypt","toString","error","console","Error","decryptData","encryptedData","bytes","decrypt","decrypted","enc","Utf8","encryptWithPassword","password","salt","lib","WordArray","random","key","deriveKey","verification","SHA256","dataWithVerification","JSON","stringify","originalData","decryptWithPassword","expectedVerification","passwordVerification","decryptedString","decryptedData","parse","warn","message","includes","hashData","generateSalt","PBKDF2","keySize","iterations","encryptMedicalRecord","record","jsonData","hash","decryptMedicalRecord","decryptedJson","verifyRecordIntegrity","expectedHash","currentHash","encryptionService"],"sources":["D:/DATA/CAREER/INTERNSHIPS/EMRChains Internship NSTP/PROJECTS/HEALTHCARE_SYSTEM/src/services/encryption.ts"],"sourcesContent":["import CryptoJS from 'crypto-js';\r\n\r\nexport class EncryptionService {\r\n  private secretKey: string;\r\n\r\n  constructor() {\r\n    // In production, this should come from environment variables\r\n    this.secretKey = process.env.REACT_APP_ENCRYPTION_KEY || 'default-secret-key';\r\n  }\r\n\r\n  encryptData(data: string): string {\r\n    try {\r\n      const encrypted = CryptoJS.AES.encrypt(data, this.secretKey).toString();\r\n      return encrypted;\r\n    } catch (error) {\r\n      console.error('Encryption failed:', error);\r\n      throw new Error('Failed to encrypt data');\r\n    }\r\n  }\r\n\r\n  decryptData(encryptedData: string): string {\r\n    try {\r\n      const bytes = CryptoJS.AES.decrypt(encryptedData, this.secretKey);\r\n      const decrypted = bytes.toString(CryptoJS.enc.Utf8);\r\n      \r\n      if (!decrypted) {\r\n        throw new Error('Failed to decrypt data - invalid key or corrupted data');\r\n      }\r\n      \r\n      return decrypted;\r\n    } catch (error) {\r\n      console.error('Decryption failed:', error);\r\n      throw new Error('Failed to decrypt data');\r\n    }\r\n  }\r\n\r\n  // Enhanced encryption with password and verification\r\n  encryptWithPassword(data: string, password: string): {encryptedData: string, salt: string, verification: string} {\r\n    try {\r\n      const salt = CryptoJS.lib.WordArray.random(128/8).toString();\r\n      const key = this.deriveKey(password, salt);\r\n      const verification = CryptoJS.SHA256(password + salt).toString();\r\n      \r\n      const dataWithVerification = JSON.stringify({\r\n        verification: verification,\r\n        originalData: data\r\n      });\r\n      \r\n      const encryptedData = CryptoJS.AES.encrypt(dataWithVerification, key).toString();\r\n      \r\n      return {\r\n        encryptedData,\r\n        salt,\r\n        verification\r\n      };\r\n    } catch (error) {\r\n      console.error('Password encryption failed:', error);\r\n      throw new Error('Failed to encrypt data with password');\r\n    }\r\n  }\r\n\r\n  // Enhanced decryption with password verification\r\n  decryptWithPassword(encryptedData: string, password: string, salt: string, expectedVerification?: string): string {\r\n    try {\r\n      const key = this.deriveKey(password, salt);\r\n      const passwordVerification = CryptoJS.SHA256(password + salt).toString();\r\n      \r\n      const bytes = CryptoJS.AES.decrypt(encryptedData, key);\r\n      const decryptedString = bytes.toString(CryptoJS.enc.Utf8);\r\n      \r\n      if (!decryptedString) {\r\n        throw new Error('Invalid password - decryption resulted in empty data');\r\n      }\r\n\r\n      let decryptedData;\r\n      try {\r\n        decryptedData = JSON.parse(decryptedString);\r\n      } catch (error) {\r\n        throw new Error('Invalid password or corrupted data - unable to parse decrypted content');\r\n      }\r\n\r\n      // Verify the password using the embedded verification hash\r\n      if (decryptedData.verification) {\r\n        if (decryptedData.verification !== passwordVerification) {\r\n          throw new Error('Invalid password - verification failed');\r\n        }\r\n        return decryptedData.originalData;\r\n      } else if (expectedVerification) {\r\n        if (expectedVerification !== passwordVerification) {\r\n          throw new Error('Invalid password - verification failed');\r\n        }\r\n        return decryptedString;\r\n      } else {\r\n        console.warn('Decryption performed without password verification');\r\n        return decryptedString;\r\n      }\r\n    } catch (error) {\r\n      console.error('Password decryption failed:', error);\r\n      if (error instanceof Error && error.message.includes('Invalid password')) {\r\n        throw error;\r\n      }\r\n      throw new Error('Failed to decrypt data with password');\r\n    }\r\n  }\r\n\r\n  hashData(data: string): string {\r\n    return CryptoJS.SHA256(data).toString();\r\n  }\r\n\r\n  generateSalt(): string {\r\n    return CryptoJS.lib.WordArray.random(128/8).toString();\r\n  }\r\n\r\n  deriveKey(password: string, salt: string): string {\r\n    return CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256/32,\r\n      iterations: 100000\r\n    }).toString();\r\n  }\r\n\r\n  encryptMedicalRecord(record: any): {encryptedData: string, hash: string} {\r\n    const jsonData = JSON.stringify(record);\r\n    const encryptedData = this.encryptData(jsonData);\r\n    const hash = this.hashData(jsonData);\r\n    \r\n    return {\r\n      encryptedData,\r\n      hash\r\n    };\r\n  }\r\n\r\n  decryptMedicalRecord(encryptedData: string): any {\r\n    const decryptedJson = this.decryptData(encryptedData);\r\n    return JSON.parse(decryptedJson);\r\n  }\r\n\r\n  verifyRecordIntegrity(record: any, expectedHash: string): boolean {\r\n    const currentHash = this.hashData(JSON.stringify(record));\r\n    return currentHash === expectedHash;\r\n  }\r\n}\r\n\r\nexport const encryptionService = new EncryptionService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}