{"ast":null,"code":"import { database } from '../config/firebase';\nimport { ref, push, set, get, remove, update, onValue, off } from 'firebase/database';\nexport class FirebaseHealthRecordsService {\n  constructor() {\n    this.RECORDS_PATH = 'healthRecords';\n    this.PATIENTS_PATH = 'patients';\n    this.DOCTORS_PATH = 'doctors';\n    this.COUNTERS_PATH = 'counters';\n  }\n  /**\r\n   * Save a new patient record to Firebase\r\n   */\n  async saveRecord(record) {\n    try {\n      const recordsRef = ref(database, this.RECORDS_PATH);\n      const newRecordRef = push(recordsRef);\n\n      // Save the record with Firebase-generated key\n      await set(newRecordRef, {\n        ...record,\n        firebaseId: newRecordRef.key,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      });\n\n      // Update patient and doctor indexes\n      await this.updatePatientIndex(record.patientId, record.patientName);\n      await this.updateDoctorIndex(record.doctorId, record.doctorName);\n      return newRecordRef.key;\n    } catch (error) {\n      console.error('Error saving record to Firebase:', error);\n      throw new Error('Failed to save record to database');\n    }\n  }\n\n  /**\r\n   * Get all patient records from Firebase\r\n   */\n  async getAllRecords() {\n    try {\n      const recordsRef = ref(database, this.RECORDS_PATH);\n      const snapshot = await get(recordsRef);\n      if (snapshot.exists()) {\n        const recordsData = snapshot.val();\n        return Object.keys(recordsData).map(key => ({\n          ...recordsData[key],\n          firebaseId: key\n        }));\n      }\n      return [];\n    } catch (error) {\n      console.error('Error fetching records from Firebase:', error);\n      throw new Error('Failed to fetch records from database');\n    }\n  }\n\n  /**\r\n   * Get a specific record by Firebase ID\r\n   */\n  async getRecordById(firebaseId) {\n    try {\n      const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\n      const snapshot = await get(recordRef);\n      if (snapshot.exists()) {\n        return {\n          ...snapshot.val(),\n          firebaseId\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching record by ID:', error);\n      throw new Error('Failed to fetch record');\n    }\n  }\n\n  /**\r\n   * Update an existing record\r\n   */\n  async updateRecord(firebaseId, updates) {\n    try {\n      const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\n      await update(recordRef, {\n        ...updates,\n        updatedAt: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error updating record:', error);\n      throw new Error('Failed to update record');\n    }\n  }\n\n  /**\r\n   * Delete a record\r\n   */\n  async deleteRecord(firebaseId) {\n    try {\n      const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\n      await remove(recordRef);\n    } catch (error) {\n      console.error('Error deleting record:', error);\n      throw new Error('Failed to delete record');\n    }\n  }\n\n  /**\r\n   * Search records by patient name\r\n   */\n  async searchRecordsByPatient(patientName) {\n    try {\n      const records = await this.getAllRecords();\n      return records.filter(record => record.patientName.toLowerCase().includes(patientName.toLowerCase()));\n    } catch (error) {\n      console.error('Error searching records:', error);\n      throw new Error('Failed to search records');\n    }\n  }\n\n  /**\r\n   * Get records by doctor\r\n   */\n  async getRecordsByDoctor(doctorName) {\n    try {\n      const records = await this.getAllRecords();\n      return records.filter(record => record.doctorName.toLowerCase().includes(doctorName.toLowerCase()));\n    } catch (error) {\n      console.error('Error fetching doctor records:', error);\n      throw new Error('Failed to fetch doctor records');\n    }\n  }\n\n  /**\r\n   * Get next available ID for records, patients, or doctors\r\n   */\n  async getNextId(type) {\n    try {\n      const counterRef = ref(database, `${this.COUNTERS_PATH}/${type}`);\n      const snapshot = await get(counterRef);\n      let currentCount = 1;\n      if (snapshot.exists()) {\n        currentCount = snapshot.val() + 1;\n      }\n\n      // Update the counter\n      await set(counterRef, currentCount);\n\n      // Return formatted ID\n      const prefix = type === 'record' ? 'MR' : type === 'patient' ? 'PT' : 'DR';\n      return `${prefix}${String(currentCount).padStart(3, '0')}`;\n    } catch (error) {\n      console.error('Error getting next ID:', error);\n      // Fallback to timestamp-based ID\n      const timestamp = Date.now();\n      const prefix = type === 'record' ? 'MR' : type === 'patient' ? 'PT' : 'DR';\n      return `${prefix}${timestamp.toString().slice(-6)}`;\n    }\n  }\n\n  /**\r\n   * Update patient index for quick lookups\r\n   */\n  async updatePatientIndex(patientId, patientName) {\n    try {\n      const patientRef = ref(database, `${this.PATIENTS_PATH}/${patientId}`);\n      await set(patientRef, {\n        name: patientName,\n        lastUpdated: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error updating patient index:', error);\n    }\n  }\n\n  /**\r\n   * Update doctor index for quick lookups\r\n   */\n  async updateDoctorIndex(doctorId, doctorName) {\n    try {\n      const doctorRef = ref(database, `${this.DOCTORS_PATH}/${doctorId}`);\n      await set(doctorRef, {\n        name: doctorName,\n        lastUpdated: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error updating doctor index:', error);\n    }\n  }\n\n  /**\r\n   * Listen to real-time updates for records\r\n   */\n  subscribeToRecords(callback) {\n    const recordsRef = ref(database, this.RECORDS_PATH);\n    const unsubscribe = onValue(recordsRef, snapshot => {\n      if (snapshot.exists()) {\n        const recordsData = snapshot.val();\n        const records = Object.keys(recordsData).map(key => ({\n          ...recordsData[key],\n          firebaseId: key\n        }));\n        callback(records);\n      } else {\n        callback([]);\n      }\n    });\n\n    // Return unsubscribe function\n    return () => off(recordsRef, 'value', unsubscribe);\n  }\n\n  /**\r\n   * Get statistics about the database\r\n   */\n  async getStatistics() {\n    try {\n      const [records, patients, doctors] = await Promise.all([this.getAllRecords(), get(ref(database, this.PATIENTS_PATH)), get(ref(database, this.DOCTORS_PATH))]);\n      return {\n        totalRecords: records.length,\n        totalPatients: patients.exists() ? Object.keys(patients.val()).length : 0,\n        totalDoctors: doctors.exists() ? Object.keys(doctors.val()).length : 0\n      };\n    } catch (error) {\n      console.error('Error getting statistics:', error);\n      return {\n        totalRecords: 0,\n        totalPatients: 0,\n        totalDoctors: 0\n      };\n    }\n  }\n\n  /**\r\n   * Backup data to localStorage as fallback\r\n   */\n  async backupToLocalStorage() {\n    try {\n      const records = await this.getAllRecords();\n      localStorage.setItem('firebaseBackup_healthRecords', JSON.stringify({\n        records,\n        timestamp: new Date().toISOString()\n      }));\n    } catch (error) {\n      console.error('Error backing up to localStorage:', error);\n    }\n  }\n\n  /**\r\n   * Restore data from localStorage backup\r\n   */\n  getLocalStorageBackup() {\n    try {\n      const backup = localStorage.getItem('firebaseBackup_healthRecords');\n      if (backup) {\n        const parsedBackup = JSON.parse(backup);\n        return parsedBackup.records || [];\n      }\n      return null;\n    } catch (error) {\n      console.error('Error reading localStorage backup:', error);\n      return null;\n    }\n  }\n}\n\n// Create and export a singleton instance\nexport const firebaseHealthRecordsService = new FirebaseHealthRecordsService();","map":{"version":3,"names":["database","ref","push","set","get","remove","update","onValue","off","FirebaseHealthRecordsService","constructor","RECORDS_PATH","PATIENTS_PATH","DOCTORS_PATH","COUNTERS_PATH","saveRecord","record","recordsRef","newRecordRef","firebaseId","key","createdAt","Date","toISOString","updatedAt","updatePatientIndex","patientId","patientName","updateDoctorIndex","doctorId","doctorName","error","console","Error","getAllRecords","snapshot","exists","recordsData","val","Object","keys","map","getRecordById","recordRef","updateRecord","updates","deleteRecord","searchRecordsByPatient","records","filter","toLowerCase","includes","getRecordsByDoctor","getNextId","type","counterRef","currentCount","prefix","String","padStart","timestamp","now","toString","slice","patientRef","name","lastUpdated","doctorRef","subscribeToRecords","callback","unsubscribe","getStatistics","patients","doctors","Promise","all","totalRecords","length","totalPatients","totalDoctors","backupToLocalStorage","localStorage","setItem","JSON","stringify","getLocalStorageBackup","backup","getItem","parsedBackup","parse","firebaseHealthRecordsService"],"sources":["D:/DATA/CAREER/INTERNSHIPS/EMRChains Internship NSTP/PROJECTS/HEALTHCARE_SYSTEM/src/services/firebaseHealthRecords.ts"],"sourcesContent":["import { database } from '../config/firebase';\r\nimport { ref, push, set, get, remove, update, onValue, off } from 'firebase/database';\r\nimport { PatientRecord } from '../types';\r\n\r\nexport class FirebaseHealthRecordsService {\r\n    private readonly RECORDS_PATH = 'healthRecords';\r\n    private readonly PATIENTS_PATH = 'patients';\r\n    private readonly DOCTORS_PATH = 'doctors';\r\n    private readonly COUNTERS_PATH = 'counters';\r\n\r\n    /**\r\n     * Save a new patient record to Firebase\r\n     */\r\n    async saveRecord(record: PatientRecord): Promise<string> {\r\n        try {\r\n            const recordsRef = ref(database, this.RECORDS_PATH);\r\n            const newRecordRef = push(recordsRef);\r\n            \r\n            // Save the record with Firebase-generated key\r\n            await set(newRecordRef, {\r\n                ...record,\r\n                firebaseId: newRecordRef.key,\r\n                createdAt: new Date().toISOString(),\r\n                updatedAt: new Date().toISOString()\r\n            });\r\n\r\n            // Update patient and doctor indexes\r\n            await this.updatePatientIndex(record.patientId, record.patientName);\r\n            await this.updateDoctorIndex(record.doctorId, record.doctorName);\r\n\r\n            return newRecordRef.key!;\r\n        } catch (error) {\r\n            console.error('Error saving record to Firebase:', error);\r\n            throw new Error('Failed to save record to database');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all patient records from Firebase\r\n     */\r\n    async getAllRecords(): Promise<PatientRecord[]> {\r\n        try {\r\n            const recordsRef = ref(database, this.RECORDS_PATH);\r\n            const snapshot = await get(recordsRef);\r\n            \r\n            if (snapshot.exists()) {\r\n                const recordsData = snapshot.val();\r\n                return Object.keys(recordsData).map(key => ({\r\n                    ...recordsData[key],\r\n                    firebaseId: key\r\n                }));\r\n            }\r\n            \r\n            return [];\r\n        } catch (error) {\r\n            console.error('Error fetching records from Firebase:', error);\r\n            throw new Error('Failed to fetch records from database');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific record by Firebase ID\r\n     */\r\n    async getRecordById(firebaseId: string): Promise<PatientRecord | null> {\r\n        try {\r\n            const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\r\n            const snapshot = await get(recordRef);\r\n            \r\n            if (snapshot.exists()) {\r\n                return {\r\n                    ...snapshot.val(),\r\n                    firebaseId\r\n                };\r\n            }\r\n            \r\n            return null;\r\n        } catch (error) {\r\n            console.error('Error fetching record by ID:', error);\r\n            throw new Error('Failed to fetch record');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update an existing record\r\n     */\r\n    async updateRecord(firebaseId: string, updates: Partial<PatientRecord>): Promise<void> {\r\n        try {\r\n            const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\r\n            await update(recordRef, {\r\n                ...updates,\r\n                updatedAt: new Date().toISOString()\r\n            });\r\n        } catch (error) {\r\n            console.error('Error updating record:', error);\r\n            throw new Error('Failed to update record');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a record\r\n     */\r\n    async deleteRecord(firebaseId: string): Promise<void> {\r\n        try {\r\n            const recordRef = ref(database, `${this.RECORDS_PATH}/${firebaseId}`);\r\n            await remove(recordRef);\r\n        } catch (error) {\r\n            console.error('Error deleting record:', error);\r\n            throw new Error('Failed to delete record');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search records by patient name\r\n     */\r\n    async searchRecordsByPatient(patientName: string): Promise<PatientRecord[]> {\r\n        try {\r\n            const records = await this.getAllRecords();\r\n            return records.filter(record => \r\n                record.patientName.toLowerCase().includes(patientName.toLowerCase())\r\n            );\r\n        } catch (error) {\r\n            console.error('Error searching records:', error);\r\n            throw new Error('Failed to search records');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get records by doctor\r\n     */\r\n    async getRecordsByDoctor(doctorName: string): Promise<PatientRecord[]> {\r\n        try {\r\n            const records = await this.getAllRecords();\r\n            return records.filter(record => \r\n                record.doctorName.toLowerCase().includes(doctorName.toLowerCase())\r\n            );\r\n        } catch (error) {\r\n            console.error('Error fetching doctor records:', error);\r\n            throw new Error('Failed to fetch doctor records');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get next available ID for records, patients, or doctors\r\n     */\r\n    async getNextId(type: 'record' | 'patient' | 'doctor'): Promise<string> {\r\n        try {\r\n            const counterRef = ref(database, `${this.COUNTERS_PATH}/${type}`);\r\n            const snapshot = await get(counterRef);\r\n            \r\n            let currentCount = 1;\r\n            if (snapshot.exists()) {\r\n                currentCount = snapshot.val() + 1;\r\n            }\r\n            \r\n            // Update the counter\r\n            await set(counterRef, currentCount);\r\n            \r\n            // Return formatted ID\r\n            const prefix = type === 'record' ? 'MR' : type === 'patient' ? 'PT' : 'DR';\r\n            return `${prefix}${String(currentCount).padStart(3, '0')}`;\r\n        } catch (error) {\r\n            console.error('Error getting next ID:', error);\r\n            // Fallback to timestamp-based ID\r\n            const timestamp = Date.now();\r\n            const prefix = type === 'record' ? 'MR' : type === 'patient' ? 'PT' : 'DR';\r\n            return `${prefix}${timestamp.toString().slice(-6)}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update patient index for quick lookups\r\n     */\r\n    private async updatePatientIndex(patientId: string, patientName: string): Promise<void> {\r\n        try {\r\n            const patientRef = ref(database, `${this.PATIENTS_PATH}/${patientId}`);\r\n            await set(patientRef, {\r\n                name: patientName,\r\n                lastUpdated: new Date().toISOString()\r\n            });\r\n        } catch (error) {\r\n            console.error('Error updating patient index:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update doctor index for quick lookups\r\n     */\r\n    private async updateDoctorIndex(doctorId: string, doctorName: string): Promise<void> {\r\n        try {\r\n            const doctorRef = ref(database, `${this.DOCTORS_PATH}/${doctorId}`);\r\n            await set(doctorRef, {\r\n                name: doctorName,\r\n                lastUpdated: new Date().toISOString()\r\n            });\r\n        } catch (error) {\r\n            console.error('Error updating doctor index:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Listen to real-time updates for records\r\n     */\r\n    subscribeToRecords(callback: (records: PatientRecord[]) => void): () => void {\r\n        const recordsRef = ref(database, this.RECORDS_PATH);\r\n        \r\n        const unsubscribe = onValue(recordsRef, (snapshot) => {\r\n            if (snapshot.exists()) {\r\n                const recordsData = snapshot.val();\r\n                const records = Object.keys(recordsData).map(key => ({\r\n                    ...recordsData[key],\r\n                    firebaseId: key\r\n                }));\r\n                callback(records);\r\n            } else {\r\n                callback([]);\r\n            }\r\n        });\r\n\r\n        // Return unsubscribe function\r\n        return () => off(recordsRef, 'value', unsubscribe);\r\n    }\r\n\r\n    /**\r\n     * Get statistics about the database\r\n     */\r\n    async getStatistics(): Promise<{\r\n        totalRecords: number;\r\n        totalPatients: number;\r\n        totalDoctors: number;\r\n    }> {\r\n        try {\r\n            const [records, patients, doctors] = await Promise.all([\r\n                this.getAllRecords(),\r\n                get(ref(database, this.PATIENTS_PATH)),\r\n                get(ref(database, this.DOCTORS_PATH))\r\n            ]);\r\n\r\n            return {\r\n                totalRecords: records.length,\r\n                totalPatients: patients.exists() ? Object.keys(patients.val()).length : 0,\r\n                totalDoctors: doctors.exists() ? Object.keys(doctors.val()).length : 0\r\n            };\r\n        } catch (error) {\r\n            console.error('Error getting statistics:', error);\r\n            return { totalRecords: 0, totalPatients: 0, totalDoctors: 0 };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Backup data to localStorage as fallback\r\n     */\r\n    async backupToLocalStorage(): Promise<void> {\r\n        try {\r\n            const records = await this.getAllRecords();\r\n            localStorage.setItem('firebaseBackup_healthRecords', JSON.stringify({\r\n                records,\r\n                timestamp: new Date().toISOString()\r\n            }));\r\n        } catch (error) {\r\n            console.error('Error backing up to localStorage:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore data from localStorage backup\r\n     */\r\n    getLocalStorageBackup(): PatientRecord[] | null {\r\n        try {\r\n            const backup = localStorage.getItem('firebaseBackup_healthRecords');\r\n            if (backup) {\r\n                const parsedBackup = JSON.parse(backup);\r\n                return parsedBackup.records || [];\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            console.error('Error reading localStorage backup:', error);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n// Create and export a singleton instance\r\nexport const firebaseHealthRecordsService = new FirebaseHealthRecordsService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}